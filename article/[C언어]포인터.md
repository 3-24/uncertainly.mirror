# [C언어]포인터

## 1. 정의

**메모리 주소를 저장하고, 특정 자료형으로 그 주소에 접근하기 위한 자료형**

포인터 변수의 크기는 32비트 컴파일러의 경우에는 4바이트, 64비트 컴파일러의 경우에는 8바이트입니다. `sizezof`함수를 이용해서 직접 확인할 수 있습니다.

##  2. 선언

 `(자료형) *변수명`으로 선언합니다. 예를 들면 다음과 같습니다.

```c++
int *pa;
char *pc;
```

`pa`는 `int *`자료형, `pc`는 `char *`자료형으로 각각 `int`의 메모리 주소, `char`의 메모리 주소를 담는 변수가 되겠습니다.

## 3. 접근(*, &)

이미 변수가 주어졌을 때 `&(변수)`로 주소를 접근하고, 역으로 포인터 변수의 값은 `*(포인터 변수)`로 접근합니다.

```c++
int *p;
int b = 3;
p = &b;
printf("%d",*p);
```

`int *`포인터 변수 `p`에 `b`의 주소를 저장하고, 나중에 출력할 때 `p`의 값을 불러오기 때문에 결과적으로 `b`에 저장된 값을 위 코드는 출력합니다.

## 4. 배열의 포인터

배열도 변수인 만큼 배열에 해당하는 포인터도 물론 있습니다. 하지만`*(포인터 변수)`와 `(포인터 변수)[0]`은 같은 결과를 불러오기 때문에 더 주의가 필요합니다.

```c++
int a[8];
int (*p)[8] = &a;
(*p)[4] = 4; // a[4] = 4와 같다.
*p[4] = 4;   // 오버플로우. p[4][0] = 4와 같다.
```

이렇게 `int [8]` 타입의 변수인 `a`의 포인터 변수`p`를 `int (*)[8]`자료형으로 선언하면 괄호 사용에 주의해야 합니다. 연산자 `*`의 우선 순위 때문에 오버플로우에 걸려들기 쉽상입니다. `*p[4]`는 `p[4][0]`이지만, `(*p)[4]`은 `p[0][4]`로 큰 차이가 있습니다.

배열의 이름이 배열의 시작 주소의 값을 가리킨다는 성질을 이용해서 포인터를 선언하기도 합니다.

```c++
int a[8];
int *p = a;
p[4] = 4;
```

이렇게 처리하면 `int`타입의 `a[0]`가 `p`에 담깁니다. 동시에 이것은 배열의 이름이기 때문에 `p`는 `a`와 완전히 같은 기능을 합니다.

## 5. 포인터의 형변환

포인터 변수를 다른 포인터 변수로 형변환해도 그 포인터 변수가 가리키는 메모리 주소는 변하지 않습니다.

```c++
char a[13] = "Hello World!"
*(long long *)&a = 0;
```

`&a`는 4/8바이트의 `char (*)[13]`타입 포인터입니다. 이것을 4/8바이트의 `long long *`타입으로  변환한 후 이 변수가 가지는 값을 0으로 지정해줍니다. ??